REMOVE_THIS=1

include "include/MLG user interface.pixih"
include "include/MLG easy programming.pixih"
include "include/Game functions.pixih"

meter_size=10
ball_size=.5
atmosphere_height=200
gravity=9.8
press_gravity=gravity*8
physics_update_frequency=1000

generation_size=2000
generation_chunk_size=150
generation_start_speed=8
generation_acceleration=.005
generation_damping=.98

star_count=1000

camera_scale=2
menu_camera_y=-atmosphere_height-WINDOW_YSIZE div 2/meter_size/camera_scale
camera_x=600/meter_size/camera_scale
camera_y=menu_camera_y

texture_stars=new(WINDOW_XSIZE, WINDOW_YSIZE)
clean(texture_stars)
texture_halo=load("share/halo.png")
set_flags(texture_halo, GL_MIN_LINEAR|GL_MAG_LINEAR|GL_NICEST)

/**Particles structure.
 * @param 0 type of particle.
 * @param 1 x.
 * @param 2 y.
 * @param 3 rotation.
 * @param 4 size.
 * @param 5 x speed.
 * @param 6 y speed.
 * @param 7 rotation speed.
 * @param 8 timestamp in physic frames.
 * @param 9 time of life in physic frames.
 * @param 10 x, calculated for rendering.
 * @param 11 y, calculated for rendering.
 * @param 12 rotation, calculated for rendering.
 * @param 13 size, calculated for rendering.
 * @param 14 calculated red color.
 * @param 15 calculated green color.
 * @param 16 calculated blue color.
 * @param 17 calculated alpha.
 */
particles=new(18, 1024, FLOAT)
clean(particles)
particles_index=0
first_time=1
fn gl_callback()
{
	time=get_timer()
	set_screen(GL_SCREEN)
	if scene
	{
		while (generation_x/*+generation_chunk_size*/)*camera_scale<WINDOW_XSIZE div 2+camera_x*meter_size*camera_scale
		{
			if generation_x-generation_offset+generation_chunk_size>=generation_size
			{
				copy(generation, generation, 0, generation_chunk_size, generation_size)
				generation_offset+generation_chunk_size
			}
			generation_speed=(rand()-16384)/32768*(generation_start_speed+generation_x/meter_size*generation_acceleration)
			while generation_next_y+generation_speed>=200||generation_next_y+generation_speed<-100
			{
				generation_speed=(rand()-16384)/32768*(generation_start_speed+generation_x/meter_size*generation_acceleration)
			}
			generation_next_y+generation_speed
			generation_acceleration2=2*(generation_next_y-generation_prev_y-generation_speed2*generation_chunk_size)/generation_chunk_size/generation_chunk_size
			a=0 while a!=generation_chunk_size
			{
				generation[generation_x-generation_offset+a]=generation_y
				generation_speed2+generation_acceleration2
				generation_speed2*pow(generation_damping, 100/generation_chunk_size)
				generation_y+generation_speed2
				a+1
			}
			generation_prev_y=generation_y
			logf("WTF: %d, %d\n", generation_x, generation_offset)
			generation_x+generation_chunk_size
		}
		if time<1000
		{
			camera_y=crossfade(time, menu_camera_y/2, 300/meter_size/camera_scale-1, 0, 1000, CURVE_FAST)
		}
		running_function=1
		done=0
		while done!=pow(2, THREADS)-1{}
		pixi(texture_stars, 0, 0)
		draw_particles(0b001)
		atmosphere()
		draw_particles(0b110)
		a=-WINDOW_XSIZE div 2 while a<WINDOW_XSIZE div 2
		{
			b=a/camera_scale+camera_x*meter_size-generation_offset
			fbox(a, (crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)-camera_y)*meter_size*camera_scale, 4, WINDOW_YSIZE div 2-(crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)-camera_y)*meter_size*camera_scale, #000000)
			a+4
		}
		if !crush
		{
			draw_ball(255, 0, 0, 255)
		}
		sprintf(0, "%d FPS.\nDistance: %f.\nSpeed: %f.", FPS, x, sqrt(x_speed*x_speed+y_speed*y_speed))
		print(0, -WINDOW_XSIZE div 2, -WINDOW_YSIZE div 2, #008080, TOP|LEFT)
		while physic_frames!=floor(time/1000*physics_update_frequency)
		{
			if floor(rand()/32768*.125*pow(meter_size*camera_scale/100, 2)*physics_update_frequency)==0
			{
				new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
			}
			if time>=1000
			{
				collide=0
				a=0 while a!=17
				{
					b=(x+x_speed/physics_update_frequency+cos(a/16*M_PI)*ball_size/2)*meter_size-generation_offset
					if y+y_speed/physics_update_frequency+sin(a/16*M_PI)*ball_size/2>=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)
					{
						vector_angle=get_vector_angle(1/meter_size, generation[b+1]-generation[b])
						vector_x=x_speed*cos(-vector_angle)-y_speed*sin(-vector_angle)
						vector_y=y_speed*cos(-vector_angle)+x_speed*sin(-vector_angle)
						if vector_y>=50
						{
							c=0 while c!=64
							{
								new_particle(x, y, 2, 2)
								c+1
							}
							crush=0//1
							//camera_x=x+6/camera_scale
							//camera_y=y+3/camera_scale
						}
						else{if vector_y>=10
						{
							c=0 while c!=64
							{
								new_particle(x, y, 2, 1)
								c+1
							}
						}}
						collide=1
						vector_y*-.1
						x_speed=vector_x*cos(vector_angle)-vector_y*sin(vector_angle)
						y_speed=vector_y*cos(vector_angle)+vector_x*sin(vector_angle)
						b=(x+cos(a/16*M_PI)*ball_size/2)*meter_size-generation_offset
						if y+sin(a/16*M_PI)*ball_size/2>=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)
						{
							c=(crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)-sin(a/16*M_PI)*ball_size/2-y)*cos(vector_angle)
							x-c*sin(vector_angle)
							y+c*cos(vector_angle)
						}
					}
					a+1
				}
				if collide&&ball_acceleration&&acceleration
				{
					x_speed+64/physics_update_frequency
				}
				x+x_speed/physics_update_frequency
				y+y_speed/physics_update_frequency
				if !crush
				{
					camera_speed_x+1000*(x+600/meter_size/camera_scale-camera_x)/physics_update_frequency
					camera_speed_x*pow(.99, 1000/physics_update_frequency)
					camera_speed_y+1000*(y+300/meter_size/camera_scale-camera_y)/physics_update_frequency
					camera_speed_y*pow(.99, 1000/physics_update_frequency)
					camera_x+camera_speed_x/physics_update_frequency
					camera_y+camera_speed_y/physics_update_frequency
					//camera_x=x+600/meter_size/camera_scale
					//camera_y=y+300/meter_size/camera_scale
				}
				if y>=-200
				{
					if sqrt(x_speed*x_speed+y_speed*y_speed)>=300
					{
						new_particle(x, y, 2, 0)
						x_speed/pow(crossfade(y, 1, 1.0001, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.0001, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}
					else{if sqrt(x_speed*x_speed+y_speed*y_speed)>=100
					{
						new_particle(x, y, 1, 0)
						x_speed/pow(crossfade(y, 1, 1.0002, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.0002, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}
					else
					{
						x_speed/pow(crossfade(y, 1, 1.00005, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.00005, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}}
				}
				if acceleration
				{
					y_speed+press_gravity/physics_update_frequency
				}
				else
				{
					y_speed+gravity/physics_update_frequency
				}
			}
			physic_frames+1
		}
	}
	else
	{
		if time<1000
		{
			while a!=floor(crossfade(time, 0, star_count, 0, 1000, CURVE_FAST))
			{
				b=floor(rand()/32768*4)
				op_cn(OP_COPY, texture_stars, SNEG, rand()/32768*(get_xsize(texture_stars)-b), rand()/32768*(get_ysize(texture_stars)-b), b+1, b+1)
				a+1
			}
			pixi(texture_stars, 0, 0)
			update_gl_data(texture_stars)
			b=crossfade(time, .5, 1, 0, 1000, CURVE_FAST)
			interface[2].y=-240/b
			interface[2].size=8/b
			transp(crossfade(time, 0, 256, 0, 1000, CURVE_LINEAR))
			draw_text(interface[2])
			t_reset()
			transp(255) 
		}
		else{if time<2000
		{
			if first_time
			{
				while a!=star_count
				{
					b=floor(rand()/32768*4)
					op_cn(OP_COPY, texture_stars, SNEG, rand()/32768*(get_xsize(texture_stars)-b), rand()/32768*(get_ysize(texture_stars)-b), b+1, b+1)
					a+1
				}
				first_time=0
			}
			a=crossfade(time, 1/8, 1, 1000, 1000, CURVE_FAST)
			interface[0].x=-200/a
			interface[0].y=-100/a
			interface[0].width=400/a
			interface[0].height=200/a
			interface[0].title.size=4/a
			interface[1].x=-300/a
			interface[1].y=150/a
			interface[1].width=100/a
			interface[1].height=100/a
			interface[1].title.size=4/a
			transp(255)
			pixi(texture_stars, 0, 0)
			interface[2].y=-240
			interface[2].size=8
			draw_text(interface[2])
			interface[3].x=crossfade(time, 300, -150, 1000, 1000, CURVE_FAST)
			transp(crossfade(time, 0, 256, 1000, 1000, CURVE_SLOW))
			draw_text(interface[3])
			transp(crossfade(time, 0, 256, 1000, 500, CURVE_LINEAR))
			draw_button(interface[0])
			draw_button(interface[1])
		}
		else
		{
			running_function=1
			done=0
			while done!=(1<<THREADS)-1{}
			if !scene_cross
			{
				if a!=1
				{
					interface[0].x=-200
					interface[0].y=-100
					interface[0].width=400
					interface[0].height=200
					interface[0].title.size=4
					interface[1].x=-300
					interface[1].y=150
					interface[1].width=100
					interface[1].height=100
					interface[1].title.size=4
					interface[3].x=-150
					transp(255)
					a=1
				}
				pixi(texture_stars, 0, 0)
				draw_particles()
				atmosphere()
				draw_text(interface[2])
				draw_text(interface[3])
				draw_button(interface[0])
				if interface[1].switch_state
				{
					interface[1].title.string="v"
					interface[1].color=GREEN
				}
				else
				{
					interface[1].title.string=-1
					interface[1].color=RED
				}
				draw_button(interface[1])
				if win.window
				{
					draw_window(win)
				}
			}
			else{if time<timestamp
			{
				camera_y=crossfade(time, menu_camera_y, menu_camera_y/2, timestamp-1000, 1000, CURVE_SLOW)
				interface[0].y=-100-(camera_y-menu_camera_y)*meter_size*camera_scale
				interface[1].y=150-(camera_y-menu_camera_y)*meter_size*camera_scale
				pixi(texture_stars, 0, 0)
				draw_particles()
				atmosphere()
				interface[2].y=-240-(camera_y-menu_camera_y)*meter_size*camera_scale
				interface[3].y=200-(camera_y-menu_camera_y)*meter_size*camera_scale
				draw_text(interface[2])
				draw_text(interface[3])
				draw_button(interface[0])
				if interface[1].switch_state
				{
					interface[1].title.string="v"
					interface[1].color=GREEN
				}
				else
				{
					interface[1].title.string=-1
					interface[1].color=RED
				}
				draw_button(interface[1])
			}}
			while physic_frames!=floor((time-2000)/1000*physics_update_frequency)
			{
				if floor(rand()/32768*.125*pow(meter_size*camera_scale/100, 2)*physics_update_frequency)==0
				{
					new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
				}
				physic_frames+1
			}
		}}
	}
	set_screen(0)
}
call_threads(thread_function)
set_gl_callback(gl_callback)
while 1
{
	if scene
	{
		camera_speed_x=0
		camera_speed_y=0
		x=0
		y=-1
		x_speed=0
		y_speed=0
		generation=new(generation_size, 1, FLOAT)
		logf("%d", generation)
		clean(generation, 100)
		generation_offset=floor(WINDOW_XSIZE div 2/camera_scale-generation_size+camera_x*meter_size)
		generation_x=0
		generation_prev_y=0
		generation_y=0
		generation_next_y=0
		generation_speed2=0
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			while get_event()
			{
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					running_function=-1
					halt
				}
				if time>=1000
				{
					if EVT[EVT_TYPE]==EVT_MOUSEBUTTONDOWN
					{
						acceleration=1
					}
					else{if EVT[EVT_TYPE]==EVT_MOUSEBUTTONUP
					{
						acceleration=0
					}}
				}
			}
		}
		remove(generation)
	}
	else
	{
		/**I don't want to flood the name space.
		 */
		interface=new(4, 1, INT)
		interface[0]=new_button("Play", -200, -100, 400, 200, BUTTON_STANDARD)
		interface[0].keyboard_key=KEY_ENTER
		set_button_callback(interface[0], {scene_cross=1 timestamp=time+1000}, 0)
		interface[1]=new_button(-1, -300, 150, 100, 100, BUTTON_SWITCH)
		interface[1].color=RED
		interface[2]=new_text("SkyBounce", 0, -240, 0, 8)
		interface[2].color=GREEN
		interface[3]=new_text("No acceleration.", 0, 200, 0, 4)
		interface[3].text_align=LEFT
		if REMOVE_THIS
		{
			win=new_window("Important!", -400, -200, 800, 400, WINDOW_ALERT, WINDOW_FLAG_DRAGGABLE)
			text=new_text("U SUS!!!", 10, 10, win.width-22, 4)
			text.align=TOP|LEFT
			text.text_align=TOP|LEFT
			bind_text(text, win)
		}
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			if time>=2000&&REMOVE_THIS&&win.window
			{
				interface[0].active=0
				interface[1].active=0
			}
			else
			{
				interface[0].active=1
				interface[1].active=1
			}
			while get_event()
			{
				if time>=2000&&!scene_cross
				{
					if REMOVE_THIS&&win.window
					{
						get_window_event(win)
					}
					get_button_event(interface[0])
					get_button_event(interface[1])
				}
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					running_function=-1
					halt
				}
			}
			if scene_cross&&time>=timestamp
			{
				scene=1
				ball_acceleration=!interface[1].switch_state
				break
			}
		}
		remove_button(interface[0])
		remove_button(interface[1])
		remove_text(interface[2])
		remove_text(interface[3])
		remove(interface)
	}
}