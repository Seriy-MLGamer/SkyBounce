include "include/mlg user interface.pixih"
include "include/mlg easy programming.pixih"

meter_size=100
ball_size=.5
atmosphere_height=200
gravity=9.8
press_gravity=gravity*8
physics_update_frequency=1000

generation_size=15000
generation_chunk_size=1500
generation_start_speed=8
generation_acceleration=.01
generation_damping=.998

star_count=1000

menu_camera_y=-atmosphere_height-WINDOW_YSIZE div 2/meter_size
camera_scale=.2
camera_x=6/camera_scale
camera_y=menu_camera_y

texture=new(WINDOW_XSIZE, WINDOW_YSIZE)
clean(texture)
//Particles structure.
//0 - type of particle.
//1 - x.
//2 - y.
//3 - rotation.
//4 - size.
//5 - x speed.
//6 - y speed.
//7 - rotation speed.
//8 - timestamp in physic frames.
//9 - time of life in physic frames.
//10 - x, calculated for rendering.
//11 - y, calculated for rendering.
//12 - rotation, calculated for rendering.
//13 - size, calculated for rendering.
//14 - calculated red color.
//15 - calculated green color.
//16 - calculated blue color.
//17 - calculated alpha.
particles=new(18, 1024, FLOAT)
clean(particles)
particles_index=0
halo=load("assets/halo.png")
//set_flags(halo, GL_MIN_LINEAR|GL_MAG_LINEAR|GL_NICEST)
first_time=1
fn gl_callback()
{
	time=get_timer()
	set_screen(GL_SCREEN)
	if scene
	{
		while (generation_x/*+generation_chunk_size*/)*camera_scale<WINDOW_XSIZE div 2+camera_x*meter_size*camera_scale
		{
			if generation_x-generation_offset+generation_chunk_size>=generation_size
			{
				copy(generation, generation, 0, generation_chunk_size, generation_size)
				generation_offset+generation_chunk_size
			}
			generation_speed=(rand()-16384)/32768*(generation_start_speed+generation_x/meter_size*generation_acceleration)
			while generation_next_y+generation_speed>=200||generation_next_y+generation_speed<-100
			{
				generation_speed=(rand()-16384)/32768*(generation_start_speed+generation_x/meter_size*generation_acceleration)
			}
			generation_next_y+generation_speed
			generation_acceleration2=2*(generation_next_y-generation_prev_y-generation_speed2*generation_chunk_size)/generation_chunk_size/generation_chunk_size
			a=0 while a!=generation_chunk_size
			{
				generation[generation_x-generation_offset+a]=generation_y
				generation_speed2+generation_acceleration2
				generation_speed2*generation_damping
				generation_y+generation_speed2
				a+1
			}
			generation_prev_y=generation_y
			logf("WTF: %d, %d\n", generation_x, generation_offset)
			generation_x+generation_chunk_size
		}
		if time<1000
		{
			camera_y=crossfade(time, menu_camera_y/2, 3/camera_scale-1, 0, 1000, CURVE_FAST)
		}
		running_function=1
		done=0
		while done!=pow(2, THREADS)-1{}
		pixi(texture, 0, 0)
		particles_render(0b001)
		atmosphere()
		particles_render(0b110)
		a=-WINDOW_XSIZE div 2 while a<WINDOW_XSIZE div 2
		{
			fbox(a, (generation[a/camera_scale+camera_x*meter_size-generation_offset]-camera_y)*meter_size*camera_scale, 4, WINDOW_YSIZE div 2-(generation[a/camera_scale+camera_x*meter_size-generation_offset]-camera_y)*meter_size*camera_scale, #000000)
			a+4
		}
		if !crush
		{
			draw_ball(255, 0, 0, 255)
		}
		sprintf(0, "%d FPS.\nDistance: %f.\nSpeed: %f.", FPS, x, sqrt(x_speed*x_speed+y_speed*y_speed))
		print(0, -WINDOW_XSIZE div 2, -WINDOW_YSIZE div 2, #008080, TOP|LEFT)
		while physic_frames!=floor(time/1000*physics_update_frequency)
		{
			if floor(rand()/32768*.125*camera_scale*camera_scale*physics_update_frequency)==0
			{
				new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
			}
			if time>=1000
			{
				a=0 while a!=17
				{
					b=(x+cos(a/16*M_PI)*ball_size/2)*meter_size-generation_offset
					if y+sin(a/16*M_PI)*ball_size/2>=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)
					{
						vector_angle=get_vector_angle(1/meter_size, generation[b+1]-generation[b])
						vector_x=x_speed*cos(-vector_angle)-y_speed*sin(-vector_angle)
						vector_y=y_speed*cos(-vector_angle)+x_speed*sin(-vector_angle)
						if vector_y>=50
						{
							c=0 while c!=64
							{
								new_particle(x, y, 2, 2)
								c+1
							}
							crush=0//1
							//camera_x=x+6/camera_scale
							//camera_y=y+3/camera_scale
						}
						else{if vector_y>=10
						{
							c=0 while c!=64
							{
								new_particle(x, y, 2, 1)
								c+1
							}
						}}
						vector_y*-.1
						x_speed=vector_x*cos(vector_angle)-vector_y*sin(vector_angle)
						y_speed=vector_y*cos(vector_angle)+vector_x*sin(vector_angle)
						if ball_acceleration&&acceleration
						{
							x_speed+50/physics_update_frequency
						}
						y=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)-sin(a/16*M_PI)*ball_size/2
					}
					a+1
				}
				x+x_speed/physics_update_frequency
				y+y_speed/physics_update_frequency
				if !crush
				{
					camera_speed_x+1000*(x+6/camera_scale-camera_x)/physics_update_frequency
					camera_speed_x*pow(.99, 1000/physics_update_frequency)
					camera_speed_y+1000*(y+3/camera_scale-camera_y)/physics_update_frequency
					camera_speed_y*pow(.99, 1000/physics_update_frequency)
					camera_x+camera_speed_x/physics_update_frequency
					camera_y+camera_speed_y/physics_update_frequency
				}
				if y>=-200
				{
					if sqrt(x_speed*x_speed+y_speed*y_speed)>=300
					{
						new_particle(x, y, 2, 0)
						x_speed/pow(crossfade(y, 1, 1.0001, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.0001, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}
					else{if sqrt(x_speed*x_speed+y_speed*y_speed)>=100
					{
						new_particle(x, y, 1, 0)
						x_speed/pow(crossfade(y, 1, 1.0002, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.0002, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}
					else
					{
						x_speed/pow(crossfade(y, 1, 1.00005, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
						y_speed/pow(crossfade(y, 1, 1.00005, -atmosphere_height, atmosphere_height, CURVE_SLOW), 1000/physics_update_frequency)
					}}
				}
				if acceleration
				{
					y_speed+press_gravity/physics_update_frequency
				}
				else
				{
					y_speed+gravity/physics_update_frequency
				}
			}
			physic_frames+1
		}
	}
	else
	{
		if time<1000
		{
			while a!=floor(crossfade(time, 0, star_count, 0, 1000, CURVE_FAST))
			{
				b=floor(rand()/32768*4)
				op_cn(OP_COPY, texture, SNEG, rand()/32768*(get_xsize(texture)-b), rand()/32768*(get_ysize(texture)-b), b+1, b+1)
				a+1
			}
			pixi(texture, 0, 0)
			update_gl_data(texture)
			b=crossfade(time, .5, 1, 0, 1000, CURVE_FAST)
			t_scale(8/b, 8/b, 1)
			transp(crossfade(time, 0, 256, 0, 1000, CURVE_LINEAR))
			print(text[0], 0, -30, GREEN)
			t_reset()
			transp(255)
		}
		else{if time<2000
		{
			if first_time
			{
				while a!=star_count
				{
					b=floor(rand()/32768*4)
					op_cn(OP_COPY, texture, SNEG, rand()/32768*(get_xsize(texture)-b), rand()/32768*(get_ysize(texture)-b), b+1, b+1)
					a+1
				}
				first_time=0
			}
			a=crossfade(time, 1/8, 1, 1000, 1000, CURVE_FAST)
			play_button.x=-200/a
			play_button.y=-100/a
			play_button.width=400/a
			play_button.height=200/a
			checkbox.x=-300/a
			checkbox.y=150/a
			checkbox.width=100/a
			checkbox.height=100/a
			transp(255)
			pixi(texture, 0, 0)
			t_scale(8, 8, 1)
			print(text[0], 0, -30, GREEN)
			t_scale(.5, .5, 1)
			transp(crossfade(time, 0, 256, 1000, 1000, CURVE_SLOW))
			print(text[2], crossfade(time, 75, -37.5, 1000, 1000, CURVE_FAST), 50, SNEG, LEFT)
			t_reset()
			transp(crossfade(time, 0, 256, 1000, 500, CURVE_LINEAR))
			draw_button(play_button, #00FFFF, text[1], 0, 4/a)
			if checkbox.switch_state
			{
				draw_button(checkbox, GREEN, "v", 0, 4/a)
			}
			else
			{
				draw_button(checkbox, RED, "", 0, 4/a)
			}
		}
		else
		{
			if !scene_cross
			{
				if a!=1
				{
					play_button.x=-200
					play_button.y=-100
					play_button.width=400
					play_button.height=200
					checkbox.x=-300
					checkbox.y=150
					checkbox.width=100
					checkbox.height=100
					transp(255)
					a=1
				}
				running_function=1
				done=0
				while done!=(1<<THREADS)-1{}
				pixi(texture, 0, 0)
				particles_render()
				atmosphere()
				t_scale(8, 8, 1)
				print(text[0], 0, -30, GREEN)
				t_scale(.5, .5, 1)
				print(text[2], -37.5, 50, SNEG, LEFT)
				t_reset()
				draw_button(play_button, #00FFFF, text[1], 0, 4)
				if checkbox.switch_state
				{
					draw_button(checkbox, GREEN, "v", 0, 4)
				}
				else
				{
					draw_button(checkbox, RED, "", 0, 4)
				}
			}
			else{if time<timestamp
			{
				camera_y=crossfade(time, menu_camera_y, menu_camera_y/2, timestamp-1000, 1000, CURVE_SLOW)
				play_button.y=-100-(camera_y-menu_camera_y)*meter_size*camera_scale
				checkbox.y=150-(camera_y-menu_camera_y)*meter_size*camera_scale
				pixi(texture, 0, 0)
				particles_render()
				atmosphere()
				t_translate(0, -(camera_y-menu_camera_y)*meter_size*camera_scale, 0)
				t_scale(8, 8, 1)
				print(text[0], 0, -30, GREEN)
				t_scale(.5, .5, 1)
				print(text[2], -37.5, 50, SNEG, LEFT)
				t_reset()
				draw_button(play_button, #00FFFF, text[1], 0, 4)
				if checkbox.switch_state
				{
					draw_button(checkbox, GREEN, "v", 0, 4)
				}
				else
				{
					draw_button(checkbox, RED, "", 0, 4)
				}
			}}
			while physic_frames!=floor((time-2000)/1000*physics_update_frequency)
			{
				if floor(rand()/32768*.125*camera_scale*camera_scale*physics_update_frequency)==0
				{
					new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
				}
				physic_frames+1
			}
		}}
	}
	set_screen(0)
}
call_threads(thread_function)
set_gl_callback(gl_callback)
while 1
{
	if scene
	{
		camera_speed_x=0
		camera_speed_y=0
		x=0
		y=-1
		x_speed=0
		y_speed=0
		ball=new(2, 32, INT16)
		generation=new(generation_size, 1, FLOAT)
		clean(generation, 100)
		generation_offset=floor(WINDOW_XSIZE div 2/camera_scale-generation_size+camera_x*meter_size)
		generation_x=0
		generation_prev_y=0
		generation_y=0
		generation_next_y=0
		generation_speed2=0
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			while get_event()
			{
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					running_function=-1
					halt
				}
				if time>=1000
				{
					if EVT[EVT_TYPE]==EVT_MOUSEBUTTONDOWN
					{
						acceleration=1
					}
					else{if EVT[EVT_TYPE]==EVT_MOUSEBUTTONUP
					{
						acceleration=0
					}}
				}
			}
		}
		remove(generation)
	}
	else
	{
		play_button=new_button(-200, -100, 400, 200, BUTTON_STANDARD)
		play_button.keyboard_key=KEY_ENTER
		checkbox=new_button(-300, 150, 100, 100, BUTTON_SWITCH)
		text=new(3, 1, INT)
		text[0]="SkyBounce"
		text[1]="Play"
		text[2]="No acceleration."
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			while get_event()
			{
				if time>=2000&&!scene_cross
				{
					get_button_event(play_button, {scene_cross=1 timestamp=time+1000}, 0)
					get_button_event(checkbox, 0, 0)
				}
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					running_function=-1
					halt
				}
			}
			if scene_cross&&time>=timestamp
			{
				scene=1
				ball_acceleration=!checkbox.switch_state
				break
			}
		}
		remove(play_button)
		remove(checkbox)
		remove(text)
	}
}
fn new_particle($x, $y, $type, $pattern)
{
	particles[0, particles_index]=$type
	particles[8, particles_index]=physic_frames
	if $type==2
	{
		particles[3, particles_index]=rand()/32768*360
		particles[7, particles_index]=crossfade(rand(), -4, 4, 0, 32768, CURVE_LINEAR)*360
		if $pattern==0
		{
			particles[1, particles_index]=$x+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
			particles[2, particles_index]=$y+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
			particles[4, particles_index]=crossfade(rand(), 1, 1.5, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
			particles[5, particles_index]=x_speed*.4+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)
			particles[6, particles_index]=y_speed*.4+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)
			particles[9, particles_index]=floor(crossfade(rand(), .035, .045, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
		}
		else
		{
			particles[9, particles_index]=floor(crossfade(rand(), .2, .3, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
			if $pattern==1
			{
				particles[1, particles_index]=$x//crossfade(rand(), $x-.05, $x+.05, 0, 32768, CURVE_LINEAR)
				particles[2, particles_index]=$y//crossfade(rand(), $y-.05, $y+.05, 0, 32768, CURVE_LINEAR)
				particles[4, particles_index]=crossfade(rand(), .4, .6, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
				particles[5, particles_index]=crossfade(rand(), -10, 10, 0, 32768, CURVE_LINEAR)
				particles[6, particles_index]=crossfade(rand(), -1, 1, 0, 32768, CURVE_LINEAR)
			}
			else
			{
				particles[1, particles_index]=$x+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
				particles[2, particles_index]=$y+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
				particles[4, particles_index]=crossfade(rand(), .8, 1.2, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
				$speed=crossfade(rand(), 8, 12, 0, 32768, CURVE_LINEAR)
				$angle=rand()/16384*M_PI
				particles[5, particles_index]=cos($angle)*$speed
				particles[6, particles_index]=sin($angle)*$speed
			}
		}
	}
	else
	{
		particles[1, particles_index]=$x
		particles[2, particles_index]=$y
		if $type==1
		{
			particles[3, particles_index]=rand()/32768*360
			if sqrt(x_speed*x_speed+y_speed*y_speed)>=200
			{
			particles[5, particles_index]=x_speed*.2+crossfade(rand(), -50, 50, 0, 32768, CURVE_LINEAR)*crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 0, 1, 200, 100, CURVE_LINEAR)
			particles[6, particles_index]=y_speed*.2+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)*crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 0, 1, 200, 100, CURVE_LINEAR)
			}
			else
			{
				particles[5, particles_index]=x_speed*.2
				particles[6, particles_index]=y_speed*.2
			}
			particles[7, particles_index]=crossfade(rand(), -4, 4, 0, 32768, CURVE_LINEAR)*360
			particles[9, particles_index]=floor(.02*physics_update_frequency)
		}
		else
		{
			particles[4, particles_index]=crossfade(rand(), .2, .4, 0, 32768, CURVE_LINEAR)
			particles[5, particles_index]=crossfade(rand(), -.5, .5, 0, 32768, CURVE_LINEAR)
			particles[6, particles_index]=crossfade(rand(), -.5, .5, 0, 32768, CURVE_LINEAR)
			particles[9, particles_index]=floor(crossfade(rand(), 4, 8, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
		}
	}
	particles_index+1
	particles_index%get_ysize(particles)
}
fn process_particle($index)
{
	if physic_frames<particles[8, $index]+particles[9, $index]
	{
		particles[10, $index]=(particles[1, $index]+crossfade(physic_frames, 0, particles[5, $index], particles[8, $index], physics_update_frequency, CURVE_LINEAR)-camera_x)*meter_size*camera_scale
		particles[11, $index]=(particles[2, $index]+crossfade(physic_frames, 0, particles[6, $index], particles[8, $index], physics_update_frequency, CURVE_LINEAR)-camera_y)*meter_size*camera_scale
		if particles[0, $index]==0
		{
			particles[13, $index]=meter_size*particles[4, $index]*camera_scale/32
			particles[17, $index]=crossfade(physic_frames, 256, 0, particles[8, $index], particles[9, $index], CURVE_SLOW)
		}
		else
		{
			particles[12, $index]=particles[3, $index]+crossfade(physic_frames, 0, particles[7, $index], particles[8, $index], physics_update_frequency, CURVE_LINEAR)
			if particles[0, $index]==1
			{
				particles[13, $index]=ball_size*meter_size*camera_scale*crossfade(physic_frames, 1, 4, particles[8, $index], particles[9, $index], CURVE_LINEAR)/M_SQRT2
				$fade=crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 256, 0, 200, 100, CURVE_FAST)
				if y>=0
				{
					$height=256
				}
				else
				{
					$height=crossfade(y, 0, 256, -atmosphere_height, atmosphere_height, CURVE_FAST)
				}
				particles[14, $index]=255
				particles[15, $index]=128+$fade/2
				particles[16, $index]=$fade
				particles[17, $index]=crossfade(physic_frames, $height, 0, particles[8, $index], particles[9, $index], CURVE_LINEAR)
			}
			else{if particles[0, $index]==2
			{
				particles[13, $index]=meter_size*particles[4, $index]*camera_scale
				$fade=crossfade(physic_frames, 768, 0, particles[8, $index], particles[9, $index], CURVE_LINEAR)
				particles[14, $index]=255
				particles[15, $index]=$fade-256
				particles[16, $index]=$fade-512
				particles[17, $index]=$fade
			}}
		}
	}
}
fn thread_function($unused, $thread)
{
	while running_function>=0
	{
		if !(done&(1<<$thread))
		{
			if running_function==1
			{
				$a=$thread while $a<get_size(particles)
				{
					process_particle($a)
					$a+THREADS
				}
			}
			done|(1<<$thread)
		}
		else
		{
			sleep(4)
		}
	}
}
fn particles_render($types)
{
	$a=0 while $a!=get_ysize(particles)
	{
		if physic_frames<particles[8, $a]+particles[9, $a]
		{
			if $types==0||$types&0b001&&particles[0, $a]==0
			{
				$transp=get_transp()
				transp(particles[17, $a])
				pixi(halo, particles[10, $a], particles[11, $a], SNEG, particles[13, $a], particles[13, $a])
				transp($transp)
			}
			else{if $types==0||$types&0b110&&(particles[0, $a]==1||particles[0, $a]==2)
			{
				t_translate(particles[10, $a], particles[11, $a], 0)
				t_rotate(particles[12, $a], 0, 0, 1)
				$transp=get_transp()
				transp(particles[17, $a])
				fbox(-particles[13, $a]/2, -particles[13, $a]/2, particles[13, $a], particles[13, $a], get_color(particles[14, $a], particles[15, $a], particles[16, $a]))
				t_reset()
				transp($transp)
			}}
		}
		$a+1
	}
}
fn atmosphere()
{
	$vertices=new(2, 16, FLOAT32)
	$colors=new(4, 16, INT8)
	clean($colors)
	$a=0 while $a!=7
	{
		$vertices[0, $a*2]=-WINDOW_XSIZE div 2
		$vertices[0, $a*2+1]=WINDOW_XSIZE div 2-1
		$vertices[1, $a*2]=(crossfade($a, -atmosphere_height, atmosphere_height, 0, 6, CURVE_LINEAR)-camera_y)*meter_size*camera_scale
		$vertices[1, $a*2+1]=$vertices[1, $a*2]
		$a+1
	}
	$vertices[0, 14]=-WINDOW_XSIZE div 2
	$vertices[0, 15]=WINDOW_XSIZE div 2-1
	$vertices[1, 14]=WINDOW_YSIZE div 2-1
	$vertices[1, 15]=$vertices[1, 14]
	op_cn(OP_COPY, $colors, 255, 3, 2, 1, 14)
	op_cn(OP_COPY, $colors, 255, 2, 0, 1, 8)
	op_cn(OP_COPY, $colors, 255, 1, 4, 1, 6)
	op_cn(OP_COPY, $colors, 255, 0, 6, 1, 6)
	$colors[1, 4]=192
	$colors[1, 5]=192
	$colors[1, 8]=192
	$colors[1, 9]=192
	gl_draw_arrays(GL_TRIANGLE_STRIP, 0, 16, 255, 255, 255, 255, -1, $vertices, $colors)
	remove($vertices)
	remove($colors)
}
fn draw_ball($red, $green, $blue, $alpha)
{
	pixi(halo, (x-camera_x)*meter_size*camera_scale, (y-camera_y)*meter_size*camera_scale, get_color($red, $green, $blue), ball_size*meter_size*camera_scale*4/64, ball_size*meter_size*camera_scale*4/64)
	generator(OP_SIN, ball, 0, ball_size/2*meter_size*camera_scale, 0, M_PI/16, 0, 0, 1, 32)
	op_cn(OP_ADD, ball, (x-camera_x)*meter_size*camera_scale, 0, 0, 1, 32)
	generator(OP_SIN, ball, M_PI/2, ball_size/2*meter_size*camera_scale, 0, M_PI/16, 1, 0, 1, 32)
	op_cn(OP_ADD, ball, (y-camera_y)*meter_size*camera_scale, 1, 0, 1, 32)
	gl_draw_arrays(GL_TRIANGLE_FAN, 0, 32, $red, $green, $blue, $alpha, -1, ball)
}