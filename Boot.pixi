include "include/mlg buttons.pixih"
include "include/mlg easy programming.pixih"

meter_size=100
ball_size=.5
atmosphere_height=200
gravity=9.8
press_gravity=100
physics_update_frequency=1000

generation_size=8192
generation_chunk_size=1024
generation_start_speed=8
generation_acceleration=.01
generation_damping=.995

star_count=1000

menu_camera_y=-atmosphere_height-WINDOW_YSIZE div 2/meter_size
camera_scale=.5
camera_x=6
camera_y=menu_camera_y

texture=new(WINDOW_XSIZE, WINDOW_YSIZE)
clean(texture)
particles=new(10, 256, FLOAT)
clean(particles)
particles_index=0
halo=load("assets/halo.png")
set_flags(halo, GL_MIN_LINEAR|GL_MAG_LINEAR|GL_NICEST)
first_time=1
fn gl_callback()
{
	time=get_timer()
	set_screen(GL_SCREEN)
	if scene
	{
		while (generation_x/*+generation_chunk_size*/)*camera_scale<WINDOW_XSIZE div 2+camera_x*meter_size*camera_scale
		{
			if generation_x-generation_offset+generation_chunk_size>=generation_size
			{
				copy(generation, generation, 0, generation_chunk_size, generation_size)
				generation_offset+generation_chunk_size
				//op_cn(OP_COPY, generation, 8192, )
			}
			generation_next_y+(rand()-16384)/32768*(generation_start_speed+generation_x/meter_size*generation_acceleration)
			generation_acceleration2=2*(generation_next_y-generation_prev_y-generation_speed*generation_chunk_size)/generation_chunk_size/generation_chunk_size
			a=0 while a!=generation_chunk_size
			{
				generation[generation_x-generation_offset+a]=generation_y
				generation_speed+generation_acceleration2
				generation_speed*generation_damping
				generation_y+generation_speed
				a+1
			}
			generation_prev_y=generation_y
			logf("WTF: %d, %d\n", generation_x, generation_offset)
			generation_x+generation_chunk_size
		}
		if time<1000
		{
			camera_y=crossfade(time, menu_camera_y/2, -1, 0, 1000, CURVE_FAST)
		}
		pixi(texture, 0, 0)
		particles_render(0b001)
		atmosphere()
		particles_render(0b110)
		a=-WINDOW_XSIZE div 2 while a!=WINDOW_XSIZE div 2
		{
			line(a, (generation[a/camera_scale+camera_x*meter_size-generation_offset]-camera_y)*meter_size*camera_scale, a, WINDOW_YSIZE div 2, 0)
			a+1
		}
		draw_ball(255, 255, 0, 255)
		sprintf(0, "X speed: %f\nY speed: %f\nSpeed module: %f", x_speed, y_speed, sqrt(x_speed*x_speed+y_speed*y_speed))
		print(0, -WINDOW_XSIZE div 2, -WINDOW_YSIZE div 2, 0, TOP|LEFT)
		while physic_frames!=floor(time/1000*physics_update_frequency)
		{
			if floor(rand()/32768*.125*camera_scale*camera_scale*physics_update_frequency)==0
			{
				new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
			}
			if time>=1000
			{
				a=0 while a!=17
				{
					b=(x+cos(a/16*M_PI)*ball_size/2)*meter_size-generation_offset
					if y+sin(a/16*M_PI)*ball_size/2>=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)
					{
						y=crossfade(b, generation[b], generation[b+1], floor(b), 1, CURVE_LINEAR)-sin(a/16*M_PI)*ball_size/2
						vector_angle=get_vector_angle(1/meter_size, generation[b+1]-generation[b])
						vector_x=x_speed*cos(-vector_angle)-y_speed*sin(-vector_angle)
						vector_y=y_speed*cos(-vector_angle)+x_speed*sin(-vector_angle)
						vector_y*-.9
						x_speed=vector_x*cos(vector_angle)-vector_y*sin(vector_angle)
						y_speed=vector_y*cos(vector_angle)+vector_x*sin(vector_angle)
						if acceleration
						{
							x_speed+100/physics_update_frequency
						}
					}
					a+1
				}
				x+x_speed/physics_update_frequency
				y+y_speed/physics_update_frequency
				camera_x=x+6
				camera_y=y+3
				if sqrt(x_speed*x_speed+y_speed*y_speed)>=100
				{
					new_particle(x, y, 1, 0)
					if y>=-200
					{
					x_speed/crossfade(y, 1, 1.0002, -200, 200, CURVE_SLOW)
					y_speed/crossfade(y, 1, 1.0002, -200, 200, CURVE_SLOW)
					}
				}
				else
				{
					if y>=-200
					{
					x_speed/crossfade(y, 1, 1.00005, -200, 200, CURVE_SLOW)
					y_speed/crossfade(y, 1, 1.00005, -200, 200, CURVE_SLOW)
					}
				}
				if acceleration
				{
					y_speed+press_gravity/physics_update_frequency
				}
				else
				{
					y_speed+gravity/physics_update_frequency
				}
			}
			physic_frames+1
		}
	}
	else
	{
		if time<1000
		{
			while a!=floor(crossfade(time, 0, star_count, 0, 1000, CURVE_FAST))
			{
				b=floor(rand()/32768*4)
				op_cn(OP_COPY, texture, SNEG, rand()/32768*(get_xsize(texture)-b), rand()/32768*(get_ysize(texture)-b), b+1, b+1)
				a+1
			}
			pixi(texture, 0, 0)
			update_gl_data(texture)
			b=crossfade(time, .5, 1, 0, 1000, CURVE_FAST)
			t_scale(8/b, 8/b, 1)
			transp(crossfade(time, 0, 256, 0, 1000, CURVE_LINEAR))
			print(text[0], 0, -30, GREEN)
			t_reset()
			transp(255)
		}
		else{if time<2000
		{
			if first_time
			{
				while a!=star_count
				{
					b=floor(rand()/32768*4)
					op_cn(OP_COPY, texture, SNEG, rand()/32768*(get_xsize(texture)-b), rand()/32768*(get_ysize(texture)-b), b+1, b+1)
					a+1
				}
				first_time=0
			}
			a=crossfade(time, 1/8, 1, 1000, 1000, CURVE_FAST)
			play_button.x=-200/a
			play_button.y=-100/a
			play_button.width=400/a
			play_button.height=200/a
			checkbox.x=-300/a
			checkbox.y=150/a
			checkbox.width=100/a
			checkbox.height=100/a
			transp(255)
			pixi(texture, 0, 0)
			t_scale(8, 8, 1)
			print(text[0], 0, -30, GREEN)
			t_scale(.5, .5, 1)
			transp(crossfade(time, 0, 256, 1000, 1000, CURVE_SLOW))
			print(text[2], crossfade(time, 75, -37.5, 1000, 1000, CURVE_FAST), 50, SNEG, LEFT)
			t_reset()
			transp(crossfade(time, 0, 256, 1000, 500, CURVE_LINEAR))
			draw_button(play_button, #00FFFF, text[1], 0, 4/a)
			if checkbox.switch_state
			{
				draw_button(checkbox, GREEN, "v", 0, 4/a)
			}
			else
			{
				draw_button(checkbox, RED, "", 0, 4/a)
			}
		}
		else
		{
			if !scene_cross
			{
				if a!=1
				{
					play_button.x=-200
					play_button.y=-100
					play_button.width=400
					play_button.height=200
					checkbox.x=-300
					checkbox.y=150
					checkbox.width=100
					checkbox.height=100
					transp(255)
					a=1
				}
				pixi(texture, 0, 0)
				particles_render()
				atmosphere()
				t_scale(8, 8, 1)
				print(text[0], 0, -30, GREEN)
				t_scale(.5, .5, 1)
				print(text[2], -37.5, 50, SNEG, LEFT)
				t_reset()
				draw_button(play_button, #00FFFF, text[1], 0, 4)
				if checkbox.switch_state
				{
					draw_button(checkbox, GREEN, "v", 0, 4)
				}
				else
				{
					draw_button(checkbox, RED, "", 0, 4)
				}
			}
			else{if time<timestamp
			{
				camera_y=crossfade(time, menu_camera_y, menu_camera_y/2, timestamp-1000, 1000, CURVE_SLOW)
				play_button.y=-100-(camera_y-menu_camera_y)*meter_size*camera_scale
				checkbox.y=150-(camera_y-menu_camera_y)*meter_size*camera_scale
				pixi(texture, 0, 0)
				particles_render()
				atmosphere()
				t_translate(0, -(camera_y-menu_camera_y)*meter_size*camera_scale, 0)
				t_scale(8, 8, 1)
				print(text[0], 0, -30, GREEN)
				t_scale(.5, .5, 1)
				print(text[2], -37.5, 50, SNEG, LEFT)
				t_reset()
				draw_button(play_button, #00FFFF, text[1], 0, 4)
				if checkbox.switch_state
				{
					draw_button(checkbox, GREEN, "v", 0, 4)
				}
				else
				{
					draw_button(checkbox, RED, "", 0, 4)
				}
			}}
			while physic_frames!=floor((time-2000)/1000*physics_update_frequency)
			{
				if floor(rand()/32768*.125*camera_scale*camera_scale*physics_update_frequency)==0
				{
					new_particle(crossfade(rand(), -WINDOW_XSIZE, WINDOW_XSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_x, crossfade(rand(), -WINDOW_YSIZE, WINDOW_YSIZE, 0, 32768, CURVE_LINEAR)/meter_size/camera_scale+camera_y, 0, 0)
				}
				physic_frames+1
			}
		}}
	}
	set_screen(0)
}
set_gl_callback(gl_callback)
while 1
{
	if scene
	{
		x=0
		y=-1
		x_speed=0
		y_speed=0
		ball=new(2, 32, INT16)
		generation=new(generation_size, 1, FLOAT)
		clean(generation, 100)
		generation_offset=floor(WINDOW_XSIZE div 2/camera_scale-generation_size+camera_x*meter_size)
		generation_x=0
		generation_prev_y=0
		generation_y=0
		generation_next_y=0
		generation_speed=0
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			while get_event()
			{
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					halt
				}
				if time>=1000
				{
					if EVT[EVT_TYPE]==EVT_MOUSEBUTTONDOWN
					{
						acceleration=1
					}
					else{if EVT[EVT_TYPE]==EVT_MOUSEBUTTONUP
					{
						acceleration=0
					}}
				}
			}
		}
		remove(generation)
	}
	else
	{
		play_button=new_button(-200, -100, 400, 200, BUTTON_TYPE_STANDARD)
		play_button.keyboard_key=KEY_ENTER
		checkbox=new_button(-300, 150, 100, 100, BUTTON_TYPE_SWITCH)
		text=new(3, 1, INT)
		text[0]="SkyBounce"
		text[1]="Play"
		text[2]="No acceleration."
		physic_frames=0
		start_timer()
		while 1
		{
			frame()
			while get_event()
			{
				if time>=2000&&!scene_cross
				{
					get_button_event(play_button, {scene_cross=1 timestamp=time+1000}, 0)
					get_button_event(checkbox, 0, 0)
				}
				if EVT[EVT_TYPE]==EVT_QUIT
				{
					halt
				}
			}
			if scene_cross&&time>=timestamp
			{
				scene=1
				ball_acceleration=!checkbox.switch_state
				break
			}
		}
		remove(play_button)
		remove(checkbox)
		remove(text)
	}
}
fn new_particle($x, $y, $type, $pattern)
{
	particles[0, particles_index]=$type
	particles[8, particles_index]=physic_frames
	if $type==2
	{
		particles[3, particles_index]=rand()/16384*M_PI
		particles[7, particles_index]=crossfade(rand(), -8, 8, 0, 32768, CURVE_LINEAR)*M_PI
		if $pattern==0
		{
			particles[1, particles_index]=$x+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
			particles[2, particles_index]=$y+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
			particles[4, particles_index]=crossfade(rand(), 1, 1.5, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
			particles[5, particles_index]=x_speed*.4+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)
			particles[6, particles_index]=y_speed*.4+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)
			particles[9, particles_index]=floor(crossfade(rand(), .035, .045, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
		}
		else
		{
			particles[9, particles_index]=floor(crossfade(rand(), .2, .3, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
			if $pattern==1
			{
				particles[1, particles_index]=$x//crossfade(rand(), $x-.05, $x+.05, 0, 32768, CURVE_LINEAR)
				particles[2, particles_index]=$y//crossfade(rand(), $y-.05, $y+.05, 0, 32768, CURVE_LINEAR)
				particles[4, particles_index]=crossfade(rand(), .4, .6, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
				particles[5, particles_index]=crossfade(rand(), -10, 10, 0, 32768, CURVE_LINEAR)
				particles[6, particles_index]=crossfade(rand(), -1, 1, 0, 32768, CURVE_LINEAR)
			}
			else
			{
				particles[1, particles_index]=$x+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
				particles[2, particles_index]=$y+crossfade(rand(), -.1, .1, 0, 32768, CURVE_LINEAR)
				particles[4, particles_index]=crossfade(rand(), .8, 1.2, 0, 32768, CURVE_LINEAR)*ball_size/M_SQRT2
				$speed=crossfade(rand(), 8, 12, 0, 32768, CURVE_LINEAR)
				$angle=rand()/16384*M_PI
				particles[5, particles_index]=cos($angle)*$speed
				particles[6, particles_index]=sin($angle)*$speed
			}
		}
	}
	else
	{
		particles[1, particles_index]=$x
		particles[2, particles_index]=$y
		if $type==1
		{
			particles[3, particles_index]=rand()/16384*M_PI
			if sqrt(x_speed*x_speed+y_speed*y_speed)>=200
			{
			particles[5, particles_index]=x_speed*.2+crossfade(rand(), -50, 50, 0, 32768, CURVE_LINEAR)*crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 0, 1, 200, 100, CURVE_LINEAR)
			particles[6, particles_index]=y_speed*.2+crossfade(rand(), -20, 20, 0, 32768, CURVE_LINEAR)*crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 0, 1, 200, 100, CURVE_LINEAR)
			}
			else
			{
				particles[5, particles_index]=x_speed*.2
				particles[6, particles_index]=y_speed*.2
			}
			particles[7, particles_index]=crossfade(rand(), -8, 8, 0, 32768, CURVE_LINEAR)*M_PI
			particles[9, particles_index]=floor(.02*physics_update_frequency)
		}
		else
		{
			particles[4, particles_index]=crossfade(rand(), .2, .4, 0, 32768, CURVE_LINEAR)
			particles[5, particles_index]=crossfade(rand(), -.5, .5, 0, 32768, CURVE_LINEAR)
			particles[6, particles_index]=crossfade(rand(), -.5, .5, 0, 32768, CURVE_LINEAR)
			particles[9, particles_index]=floor(crossfade(rand(), 4, 8, 0, 32768, CURVE_LINEAR)*physics_update_frequency)
		}
	}
	particles_index+1
	particles_index%get_ysize(particles)
}
fn thread_function($thread)
{
	$thread-1
	while 1
	{
		if running_function!=0
		{
			if running_function==1
			{
				particles_render($thread)
			}
			else
			{
				ret
			}
		}
		else
		{
			sleep(2)
		}
	}
}
fn particles_render($types)
{
	$a=0 while $a!=get_ysize(particles)
	{
		if physic_frames>=particles[8, $a]&&physic_frames-particles[8, $a]<particles[9, $a]
		{
			$scaled=meter_size*particles[4, $a]*camera_scale
			$scaled_x=(particles[1, $a]+crossfade(physic_frames, 0, particles[5, $a], particles[8, $a], physics_update_frequency, CURVE_LINEAR)-camera_x)*meter_size*camera_scale
			$scaled_y=(particles[2, $a]+crossfade(physic_frames, 0, particles[6, $a], particles[8, $a], physics_update_frequency, CURVE_LINEAR)-camera_y)*meter_size*camera_scale
			if $types==0||$types&0b001&&particles[0, $a]==0
			{
				$transp=get_transp()
				transp(crossfade(physic_frames, 256, 0, particles[8, $a], particles[9, $a], CURVE_SLOW))
				pixi(halo, $scaled_x, $scaled_y, SNEG, $scaled/32, $scaled/32)
				transp($transp)
			}
			else{if $types==0||$types&0b010&&particles[0, $a]==1
			{
				$scaled=ball_size*meter_size*camera_scale*crossfade(physic_frames, 1, crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 4, 4, 100, 200, CURVE_LINEAR), particles[8, $a], particles[9, $a], CURVE_LINEAR)/M_SQRT2
				$fade=crossfade(sqrt(x_speed*x_speed+y_speed*y_speed), 256, 0, 200, 100, CURVE_FAST)
				draw_square_particle($scaled_x, $scaled_y, $scaled, particles[3, $a]+crossfade(physic_frames, 0, particles[7, $a], particles[8, $a], physics_update_frequency, CURVE_LINEAR), 255, 128+$fade/2, $fade, crossfade(physic_frames, 256, 0, particles[8, $a], particles[9, $a], CURVE_LINEAR))
			}
			else{if $types==0||$types&0b100&&particles[0, $a]==2
			{
				$fade=crossfade(physic_frames, 768, 0, particles[8, $a], particles[9, $a], CURVE_LINEAR)
				draw_square_particle($scaled_x, $scaled_y, $scaled, particles[3, $a]+crossfade(physic_frames, 0, particles[7, $a], particles[8, $a], physics_update_frequency, CURVE_LINEAR), 255, $fade-256, $fade-512, $fade)
			}}}
		}
		$a+1
	}
}
fn draw_square_particle($x, $y, $width, $rotation, $red, $green, $blue, $alpha)
{
	$width-1
	$vertices=new(2, 4, INT16)
	$vertices[0, 0]=floor((sin($rotation)-cos($rotation))*$width/2)
	$vertices[0, 1]=floor(-(sin($rotation)+cos($rotation))*$width/2)
	$vertices[1, 0]=floor((sin($rotation)+cos($rotation))*$width/2)
	$vertices[1, 1]=$vertices[0, 0]
	$vertices[0, 2]=floor((cos($rotation)-sin($rotation))*$width/2)
	$vertices[1, 2]=$vertices[0, 1]
	$vertices[0, 3]=$vertices[1, 0]
	$vertices[1, 3]=$vertices[0, 2]
	$a=0 while $a!=4
	{
		$vertices[0, $a]+$x
		$vertices[1, $a]+$y
		$a+1
	}
	gl_draw_arrays(GL_TRIANGLE_FAN, 0, 4, $red, $green, $blue, $alpha, -1, $vertices)
	remove($vertices)
}
fn atmosphere()
{
	$vertices=new(2, 16, FLOAT32)
	$colors=new(4, 16, INT8)
	clean($colors)
	$a=0 while $a!=7
	{
		$vertices[0, $a*2]=-WINDOW_XSIZE div 2
		$vertices[0, $a*2+1]=WINDOW_XSIZE div 2-1
		$vertices[1, $a*2]=(crossfade($a, -atmosphere_height, atmosphere_height, 0, 6, CURVE_LINEAR)-camera_y)*meter_size*camera_scale
		$vertices[1, $a*2+1]=$vertices[1, $a*2]
		$a+1
	}
	$vertices[0, 14]=-WINDOW_XSIZE div 2
	$vertices[0, 15]=WINDOW_XSIZE div 2-1
	$vertices[1, 14]=WINDOW_YSIZE div 2-1
	$vertices[1, 15]=$vertices[1, 14]
	op_cn(OP_COPY, $colors, 255, 3, 2, 1, 14)
	op_cn(OP_COPY, $colors, 255, 2, 0, 1, 8)
	op_cn(OP_COPY, $colors, 255, 1, 4, 1, 6)
	op_cn(OP_COPY, $colors, 255, 0, 6, 1, 6)
	$colors[1, 4]=192
	$colors[1, 5]=192
	$colors[1, 8]=192
	$colors[1, 9]=192
	gl_draw_arrays(GL_TRIANGLE_STRIP, 0, 16, 255, 255, 255, 255, -1, $vertices, $colors)
	remove($vertices)
	remove($colors)
}
fn draw_ball($red, $green, $blue, $alpha)
{
	generator(OP_SIN, ball, 0, ball_size/2*meter_size*camera_scale, 0, M_PI/16, 0, 0, 1, 32)
	op_cn(OP_ADD, ball, (x-camera_x)*meter_size*camera_scale, 0, 0, 1, 32)
	generator(OP_SIN, ball, M_PI/2, ball_size/2*meter_size*camera_scale, 0, M_PI/16, 1, 0, 1, 32)
	op_cn(OP_ADD, ball, (y-camera_y)*meter_size*camera_scale, 1, 0, 1, 32)
	gl_draw_arrays(GL_TRIANGLE_FAN, 0, 32, $red, $green, $blue, $alpha, -1, ball)
}